{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-fb1b9b1f-5870-46ec-8b8d-769a26ac3a37",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Identified Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to buffer overflows, memory leaks, or other memory-related issues. In the provided code snippet, `malloc(namelen * sizeof(**buffer))`, the vulnerability may occur if `namelen` is not properly validated, leading to an incorrect allocation size. This can result in undefined behavior, including potential security vulnerabilities such as buffer overflows.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input values to ensure they are within expected ranges before using them in memory allocation functions.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `new` in C++ or `std::vector` for dynamic memory management.\n3. **Check for Allocation Failure**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Initialize Allocated Memory**: Use functions like `calloc` or explicitly initialize memory to prevent the use of uninitialized memory.\n5. **Free Allocated Memory**: Ensure that all dynamically allocated memory is properly freed to prevent memory leaks.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib>  // For malloc and free\n#include <cstring>  // For memset\n\nvoid allocateBuffer(char*** buffer, size_t namelen) {\n    if (namelen == 0 || namelen > SIZE_MAX / sizeof(**buffer)) {\n        // Handle error: invalid size\n        return;\n    }\n\n    *buffer = static_cast<char**>(malloc(namelen * sizeof(**buffer)));\n    if (*buffer == nullptr) {\n        // Handle error: allocation failed\n        return;\n    }\n\n    // Optionally initialize memory\n    memset(*buffer, 0, namelen * sizeof(**buffer));\n}\n\n// Don't forget to free the allocated memory when done\nvoid freeBuffer(char*** buffer) {\n    if (buffer && *buffer) {\n        free(*buffer);\n        *buffer = nullptr;\n    }\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n- `<cstring>`: Required for `memset`.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)\n\nThese links have been verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-fee16a34-ee94-4a93-a9ee-ec7430ec46bf",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper handling of memory allocation using the `malloc` function. This can lead to various issues such as buffer overflows, memory leaks, or undefined behavior if the allocated memory is not properly managed. Specifically, when using `malloc(size_buffer)`, if `size_buffer` is not correctly calculated or validated, it can result in insufficient memory allocation or excessive allocation, leading to potential security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Validate Input:** Ensure that the size passed to `malloc` is properly validated and does not exceed expected limits.\n2. **Check Return Value:** Always check the return value of `malloc` to ensure that memory allocation was successful.\n3. **Use Safer Alternatives:** Consider using safer alternatives like `new` in C++ or higher-level data structures that manage memory automatically.\n4. **Free Allocated Memory:** Ensure that all allocated memory is properly freed to prevent memory leaks.\n5. **Use Static Analysis Tools:** Employ static analysis tools to detect potential memory management issues in the code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstdlib> // Required for malloc and free\n\nint main() {\n    size_t size_buffer = 1024; // Example buffer size\n    if (size_buffer <= 0 || size_buffer > SIZE_MAX / sizeof(char)) {\n        std::cerr << \"Invalid buffer size\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    char* buffer = (char*)malloc(size_buffer);\n    if (buffer == nullptr) {\n        std::cerr << \"Memory allocation failed\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    // Use the buffer for some operations\n\n    free(buffer); // Free the allocated memory\n    return EXIT_SUCCESS;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstdlib>`: For `malloc` and `free` functions.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-401: Missing Release of Memory after Effective Lifetime](https://cwe.mitre.org/data/definitions/401.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-957b9707-d599-4382-bf0f-a52a23231b24",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability \"Detected Use of Prohibited C Function (strncpy)\" arises when the `strncpy` function is used improperly, potentially leading to buffer overflows or data truncation. In C++, `strncpy` is often used to copy strings, but it does not guarantee null-termination if the source string is longer than the specified number of characters. This can result in undefined behavior if the destination buffer is used as a C-style string. Additionally, if the destination buffer is not large enough to hold the source string, it can lead to buffer overflows, which are a common security vulnerability.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Prefer using safer string handling functions like `strlcpy` or C++ standard library functions such as `std::string` which manage memory automatically and provide bounds checking.\n2. **Ensure Null-Termination**: Always ensure that the destination buffer is null-terminated after using `strncpy`.\n3. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Input Validation**: Validate and sanitize all input data to ensure it meets expected formats and lengths before processing.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strncpy` with a safer alternative. If using C++11 or later, consider using `std::string` for automatic memory management and bounds checking.\n\n```cpp\n#include <string>\n#include <cstring> // For std::strncpy\n\nvoid safeCopy(char* buffer, size_t bufferSize, const std::string& source) {\n    if (source.size() < bufferSize) {\n        std::strncpy(buffer, source.c_str(), bufferSize - 1);\n        buffer[bufferSize - 1] = '\\0'; // Ensure null-termination\n    } else {\n        // Handle error: source string is too large for the buffer\n    }\n}\n\n// Usage\nvoid exampleUsage(user_info_t* user_info, size_t bufferSize) {\n    char* buffer = new char[bufferSize];\n    std::string source = user_info->pw_name;\n    safeCopy(buffer, bufferSize, source);\n    // Use buffer...\n    delete[] buffer;\n}\n```\n\n### Library Dependencies\n\n- `<string>`: For using `std::string`.\n- `<cstring>`: For using `std::strncpy`.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-a5bac319-6d2c-4ea1-816e-56ec2b913218",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ arises when the `malloc` function is used improperly, leading to potential memory allocation issues. In the provided code snippet, the `malloc` function is used to allocate memory for a multi-dimensional array. However, the calculation of the size to be allocated is incorrect, which can lead to buffer overflows, memory corruption, or undefined behavior.\n\n### Vulnerability Sink\n\n```cpp\nmalloc(sizeof(unsigned[devices_count][per_device_data_saved][buffer_size]))\n```\n\nThe issue here is that `sizeof` is being used incorrectly. The expression inside `sizeof` is not evaluated as expected, leading to incorrect memory allocation. This can cause the program to access memory out of bounds, resulting in potential security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Correct Memory Allocation**: Ensure that the size calculation for `malloc` is correct. Use the correct data type size and multiply by the number of elements required.\n2. **Use Safer Alternatives**: Consider using `new` in C++ for memory allocation, which provides type safety and can throw exceptions on failure.\n3. **Check Return Values**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n4. **Initialize Memory**: Use functions like `calloc` that initialize memory to zero, reducing the risk of using uninitialized memory.\n5. **Bounds Checking**: Implement bounds checking to prevent buffer overflows.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstdlib> // Required for malloc and free\n\nunsigned*** allocateMemory(size_t devices_count, size_t per_device_data_saved, size_t buffer_size) {\n    unsigned*** data = (unsigned***)malloc(devices_count * sizeof(unsigned**));\n    if (data == nullptr) {\n        // Handle allocation failure\n        return nullptr;\n    }\n\n    for (size_t i = 0; i < devices_count; ++i) {\n        data[i] = (unsigned**)malloc(per_device_data_saved * sizeof(unsigned*));\n        if (data[i] == nullptr) {\n            // Handle allocation failure\n            // Free previously allocated memory\n            for (size_t j = 0; j < i; ++j) {\n                free(data[j]);\n            }\n            free(data);\n            return nullptr;\n        }\n\n        for (size_t j = 0; j < per_device_data_saved; ++j) {\n            data[i][j] = (unsigned*)malloc(buffer_size * sizeof(unsigned));\n            if (data[i][j] == nullptr) {\n                // Handle allocation failure\n                // Free previously allocated memory\n                for (size_t k = 0; k < j; ++k) {\n                    free(data[i][k]);\n                }\n                free(data[i]);\n                for (size_t k = 0; k < i; ++k) {\n                    free(data[k]);\n                }\n                free(data);\n                return nullptr;\n            }\n        }\n    }\n\n    return data;\n}\n```\n\n### Library Dependencies\n\n- `<cstdlib>`: Required for `malloc` and `free`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-ef70b678-ba6d-48f9-999b-41a5433cfcec",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the use of the `strlen` function in C++ arises when it is used on user-controlled input without proper validation. The function `strlen(user_info->pw_name)` can lead to a buffer overflow or other security issues if `pw_name` is not properly null-terminated or if it points to an invalid memory location. This can result in undefined behavior, including potential crashes or exploitation by attackers to execute arbitrary code.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all user inputs are validated and sanitized before being processed.\n2. **Use Safer Alternatives**: Consider using safer string handling functions that limit the number of characters processed, such as `strnlen`.\n3. **Memory Management**: Ensure that all strings are properly null-terminated and that memory is correctly allocated and freed.\n4. **Bounds Checking**: Always perform bounds checking when dealing with strings and buffers.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strlen` with `strnlen` to limit the number of characters processed and prevent buffer overflows. Here is a code example:\n\n```cpp\n#include <cstring>\n#include <pwd.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <iostream>\n\n#define MAX_NAME_LENGTH 256\n\nint main() {\n    struct passwd *user_info;\n    uid_t uid = getuid();\n    user_info = getpwuid(uid);\n\n    if (user_info != nullptr) {\n        // Use strnlen to limit the length of the string processed\n        size_t name_length = strnlen(user_info->pw_name, MAX_NAME_LENGTH);\n        if (name_length < MAX_NAME_LENGTH) {\n            std::cout << \"User name length: \" << name_length << std::endl;\n        } else {\n            std::cerr << \"User name is too long or not properly null-terminated.\" << std::endl;\n        }\n    } else {\n        std::cerr << \"Failed to retrieve user information.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following libraries are required:\n\n- `<cstring>`: For string handling functions.\n- `<pwd.h>`: For accessing the password database.\n- `<unistd.h>`: For accessing POSIX operating system API.\n- `<sys/types.h>`: For data types used in system calls.\n- `<iostream>`: For input and output stream operations.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-8214567d-089d-45ab-a2fa-b7c73aba017c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of `strncpy` in C++ can lead to vulnerabilities if not handled correctly. `strncpy` is often used to copy strings with a specified maximum length, but it does not guarantee null-termination of the destination string if the source string is longer than the specified length. This can lead to buffer overflows, data corruption, and security vulnerabilities.\n\nIn the given code snippet:\n\n```cpp\nstrncpy(thisGPU->base.pdev, pdev_val, PDEV_LEN);\n```\n\nIf `pdev_val` is not null-terminated or is longer than `PDEV_LEN`, `thisGPU->base.pdev` may not be null-terminated, leading to potential vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` which ensure null-termination.\n2. **Manual Null-Termination**: Always manually null-terminate the destination buffer after using `strncpy`.\n3. **Buffer Size Validation**: Ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe string operations.\n\n### Source Code Fix Recommendation\n\nReplace `strncpy` with a safer alternative or ensure null-termination:\n\n```cpp\n// Ensure null-termination after strncpy\nstrncpy(thisGPU->base.pdev, pdev_val, PDEV_LEN - 1);\nthisGPU->base.pdev[PDEV_LEN - 1] = '\\0';\n```\n\nOr use `strlcpy` if available:\n\n```cpp\n// Use strlcpy for safer string copy\nstrlcpy(thisGPU->base.pdev, pdev_val, PDEV_LEN);\n```\n\n### Library Dependencies\n\nThe code example does not require any additional library dependencies beyond the standard C++ libraries. However, if using `strlcpy`, ensure that it is available on your platform or consider implementing a custom version.\n\n### OWASP Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-e870b06d-196a-4075-aa7d-58cbeefc2158",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function in C++ programming. This function does not perform bounds checking on the destination buffer, which can lead to buffer overflow vulnerabilities. Buffer overflows can be exploited by attackers to execute arbitrary code, cause a program crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or C++ string handling functions such as `std::string` and its member functions.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source string, including the null terminator.\n3. **Input Validation**: Validate and sanitize all input data to ensure it does not exceed expected sizes.\n4. **Static Analysis Tools**: Use static analysis tools to detect and fix buffer overflow vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nReplace the vulnerable `strcpy` call with a safer alternative. Here is a fixed version of the code using `strncpy`:\n\n```cpp\n#include <cstring> // Required for strncpy\n#include <iostream> // Required for std::cout\n\nstruct Options {\n    const char* config_file_location;\n};\n\nvoid safeCopy(char* folder_path, const Options* options, size_t buffer_size) {\n    // Use strncpy to prevent buffer overflow\n    strncpy(folder_path, options->config_file_location, buffer_size - 1);\n    // Ensure null termination\n    folder_path[buffer_size - 1] = '\\0';\n}\n\nint main() {\n    const size_t buffer_size = 256;\n    char folder_path[buffer_size];\n    Options options = { \"/path/to/config/file\" };\n\n    safeCopy(folder_path, &options, buffer_size);\n\n    std::cout << \"Folder Path: \" << folder_path << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-61e643b1-74f1-465f-8233-3a545e92fc58",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to buffer overflows, memory leaks, or undefined behavior. In the specific case of `malloc(strlen(default_path))`, the vulnerability occurs because `malloc` is allocating memory based on the length of the string without accounting for the null terminator. This can lead to buffer overflows when the string is copied into the allocated memory.\n\n### General Mitigation Advice\n\n1. **Allocate Sufficient Memory**: Always allocate enough memory to include the null terminator when dealing with strings.\n2. **Use Safer Functions**: Consider using safer alternatives like `strdup` or C++ constructs like `std::string` which handle memory management automatically.\n3. **Input Validation**: Validate inputs to ensure they are within expected bounds before processing.\n4. **Error Checking**: Always check the return value of `malloc` to ensure memory allocation was successful.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <cstring>  // For strlen, strcpy\n#include <cstdlib>  // For malloc, free\n\nvoid exampleFunction(const char* default_path) {\n    // Allocate memory including space for the null terminator\n    char* path_copy = (char*)malloc(strlen(default_path) + 1);\n    if (path_copy == nullptr) {\n        // Handle memory allocation failure\n        return;\n    }\n    // Safely copy the string\n    strcpy(path_copy, default_path);\n\n    // Use path_copy...\n\n    // Free the allocated memory\n    free(path_copy);\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strlen` and `strcpy`.\n- `<cstdlib>`: Required for `malloc` and `free`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-11a87b7c-f4c6-49e7-a096-4867559d681c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function in C++. This function does not perform bounds checking on the destination buffer, which can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer. This can result in undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or C++ string handling functions that perform bounds checking.\n2. **Input Validation**: Ensure that input data is validated and sanitized to prevent buffer overflows.\n3. **Buffer Size Management**: Always ensure that destination buffers are large enough to hold the source data, including the null terminator.\n4. **Use Modern C++ Features**: Prefer using C++ standard library features such as `std::string` which handle memory management and bounds checking automatically.\n\n### Source Code Fix Recommendation\n\nReplace the vulnerable `strcpy` usage with a safer alternative. Here is a fixed version of the code using `strncpy`:\n\n```cpp\n#include <cstring> // Required for strncpy\n#include <algorithm> // Required for std::min\n\n// Assuming options->config_file_location is a char array with a known size\nconst size_t buffer_size = sizeof(options->config_file_location);\nstrncpy(options->config_file_location, config_location, buffer_size - 1);\noptions->config_file_location[buffer_size - 1] = '\\0'; // Ensure null termination\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For using `strncpy`.\n- `<algorithm>`: For using `std::min` if needed for additional safety checks.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/): A list of the top ten security risks for web applications.\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/): A quick reference guide for secure coding practices.\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-51d7b0bc-87bc-47c3-b737-7c9f7397ae41",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when it is used improperly, leading to potential buffer overflows or reading beyond the intended memory bounds. This can occur if `strlen` is called on a string that is not null-terminated or if the pointer passed to `strlen` is invalid. In the specific case of `strlen(default_path)`, if `default_path` is not properly initialized or null-terminated, it can lead to undefined behavior, potentially causing a program crash or allowing an attacker to execute arbitrary code.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Initialization**: Always initialize strings and ensure they are null-terminated before passing them to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions like `strnlen` or C++ standard library alternatives such as `std::string` which manage memory more safely.\n3. **Input Validation**: Validate all inputs to ensure they are within expected bounds and properly formatted.\n4. **Memory Management**: Use smart pointers or other memory management techniques to avoid dangling pointers and ensure memory is properly allocated and deallocated.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint main() {\n    const char* default_path = \"/some/default/path\"; // Ensure this is a valid, null-terminated string\n\n    // Check if default_path is not null\n    if (default_path != nullptr) {\n        size_t length = strlen(default_path);\n        std::cout << \"Length of default_path: \" << length << std::endl;\n    } else {\n        std::cerr << \"Error: default_path is null.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstring>`: Required for using `strlen`.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-74594c9d-c1de-46c6-ae29-1b271533672d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (malloc)\" vulnerability in C++ typically arises from improper use of the `malloc` function, which can lead to buffer overflows, memory leaks, or undefined behavior. In the specific case of `malloc(strlen(config_location))`, the vulnerability is due to not allocating enough memory to store the string, as `strlen` returns the length of the string without including the null terminator. This can lead to buffer overflow when the string is copied into the allocated memory.\n\n### General Mitigation Advice\n\n1. **Allocate Sufficient Memory**: Always allocate enough memory to accommodate the data and any additional space required, such as a null terminator for strings.\n2. **Use Safer Functions**: Consider using safer alternatives like `strdup` or C++ constructs like `std::string` which handle memory management automatically.\n3. **Input Validation**: Validate input lengths and ensure they are within expected bounds before performing memory allocations.\n4. **Error Checking**: Always check the return value of `malloc` to ensure that memory allocation was successful.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability sink, ensure that you allocate enough memory for the string and the null terminator:\n\n```cpp\n#include <cstring>  // For strlen\n#include <cstdlib>  // For malloc, free\n\nvoid exampleFunction(const char* config_location) {\n    // Allocate memory for the string plus the null terminator\n    char* buffer = (char*)malloc(strlen(config_location) + 1);\n    if (buffer == nullptr) {\n        // Handle memory allocation failure\n        return;\n    }\n    strcpy(buffer, config_location);  // Copy the string safely\n    // Use the buffer...\n    free(buffer);  // Free the allocated memory\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<cstring>`: For `strlen` and `strcpy`.\n- `<cstdlib>`: For `malloc` and `free`.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-122: Heap-based Buffer Overflow](https://cwe.mitre.org/data/definitions/122.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-e53f003a-a787-4483-bccb-60633b86221f",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function, which does not perform bounds checking and can lead to buffer overflow vulnerabilities. This can result in undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or `std::string` in C++.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source data, including the null terminator.\n3. **Input Validation**: Validate all inputs to ensure they do not exceed expected sizes.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in your codebase.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strcpy` with `strncpy` to prevent buffer overflow. Ensure that the destination buffer is properly sized and that the length of the copy operation is limited to the size of the destination buffer minus one for the null terminator.\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Assuming config_file_path is properly sized\nsize_t buffer_size = /* size of config_file_path */;\nstrncpy(config_file_path + xdg_path_length + 1 + conf_path_length, config_file_location, buffer_size - (xdg_path_length + 1 + conf_path_length) - 1);\nconfig_file_path[buffer_size - 1] = '\\0'; // Ensure null termination\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for using `strncpy`.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-a3a5e20d-408b-4714-8840-38765af1cc98",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises when the `strcpy` function is used in C++ programming. This function does not perform bounds checking on the destination buffer, which can lead to buffer overflow vulnerabilities. Buffer overflows can be exploited by attackers to execute arbitrary code, cause a program crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or C++ string handling functions such as `std::string` and its member functions.\n2. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the source string, including the null terminator.\n3. **Input Validation**: Validate and sanitize all input data to ensure it does not exceed expected sizes.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage and potential buffer overflows.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strcpy` with `strncpy` to prevent buffer overflow. Ensure that the destination buffer is large enough to accommodate the source string and the null terminator.\n\n```cpp\n#include <cstring> // Required for strncpy\n#include <iostream> // Required for std::cout\n\nint main() {\n    const char* xdg_config_dir = \"/path/to/config\";\n    char config_file_path[256]; // Ensure this buffer is large enough\n\n    // Use strncpy instead of strcpy\n    strncpy(config_file_path, xdg_config_dir, sizeof(config_file_path) - 1);\n    config_file_path[sizeof(config_file_path) - 1] = '\\0'; // Null-terminate the string\n\n    std::cout << \"Config file path: \" << config_file_path << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `strncpy`.\n- `<iostream>`: Required for `std::cout`.\n\n### OWASP Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-07baed74-7e74-4402-8486-6fd221306fa5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises from the use of the `strcpy` function in C++ programming. This function does not perform bounds checking on the destination buffer, which can lead to buffer overflow vulnerabilities. Buffer overflows can be exploited by attackers to execute arbitrary code, cause a program crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or C++ string handling functions that perform bounds checking.\n2. **Input Validation**: Always validate input data to ensure it does not exceed buffer sizes.\n3. **Buffer Size Management**: Ensure that destination buffers are adequately sized to handle the maximum expected input size plus a null terminator.\n4. **Use Modern C++ Features**: Prefer using C++ standard library features such as `std::string` which handle memory management and bounds checking automatically.\n\n### Source Code Fix Recommendation\n\nReplace the vulnerable `strcpy` usage with a safer alternative. Here is a fixed version of the code using `strncpy`:\n\n```cpp\n#include <cstring> // Required for strncpy\n#include <cstddef> // Required for size_t\n\n// Assuming options->config_file_location is a char array with a known size\nconst size_t buffer_size = sizeof(options->config_file_location);\nstrncpy(options->config_file_location, default_path, buffer_size - 1);\noptions->config_file_location[buffer_size - 1] = '\\0'; // Ensure null termination\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For using `strncpy`.\n- `<cstddef>`: For using `size_t`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-81eac07d-62e9-49bd-b91d-e0b7fe5c2d5e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when the function is used without proper validation of the input string. If `strlen` is called on a null pointer or an improperly terminated string, it can lead to undefined behavior, including potential crashes or security vulnerabilities such as buffer overflows. This is particularly dangerous when the input is derived from untrusted sources, as it can be exploited to execute arbitrary code or cause denial of service.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input strings before using them with `strlen`. Ensure that the input is not a null pointer and is properly null-terminated.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that provide bounds checking, such as `strnlen` or C++ standard library classes like `std::string`.\n3. **Error Handling**: Implement robust error handling to manage unexpected or malformed input gracefully.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability associated with `strlen(config_location)`, ensure that `config_location` is a valid, null-terminated string before calling `strlen`. Here is a code example with a fix:\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <stdexcept> // Required for std::runtime_error\n\nvoid processConfigLocation(const char* config_location) {\n    if (config_location == nullptr) {\n        throw std::runtime_error(\"Config location is a null pointer\");\n    }\n\n    // Ensure the string is null-terminated\n    size_t max_length = 1024; // Define a reasonable maximum length\n    size_t length = strnlen(config_location, max_length);\n    if (length == max_length) {\n        throw std::runtime_error(\"Config location string is not properly null-terminated\");\n    }\n\n    // Safe to use strlen now\n    size_t config_length = strlen(config_location);\n    std::cout << \"Config location length: \" << config_length << std::endl;\n}\n\nint main() {\n    const char* config_location = \"/path/to/config\";\n    try {\n        processConfigLocation(config_location);\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: For input and output operations.\n- `<cstring>`: For C-style string handling functions like `strlen` and `strnlen`.\n- `<stdexcept>`: For standard exception handling.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/): A list of the most critical web application security risks.\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/): A quick reference guide for secure coding practices.\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-2aa1d867-653b-4ff1-b7ff-29e170699a6d",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of the `strcpy` function in C++ can lead to buffer overflow vulnerabilities if not properly managed. This is because `strcpy` does not perform bounds checking on the destination buffer, which can result in overwriting adjacent memory and potentially leading to arbitrary code execution or program crashes. The specific vulnerability sink in the code snippet:\n\n```cpp\nstrcpy(config_file_path + xdg_path_length + 1, config_conf_path);\n```\n\nis susceptible to buffer overflow if `config_conf_path` is larger than the remaining space in `config_file_path` after `xdg_path_length + 1`.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or `std::string` operations that include bounds checking.\n2. **Validate Input**: Ensure that the size of the source string does not exceed the size of the destination buffer.\n3. **Use Modern C++ Features**: Prefer using C++ standard library features such as `std::string` which handle memory management and bounds checking automatically.\n\n### Source Code Fix Recommendation\n\nReplace the `strcpy` call with `strncpy` to ensure that the destination buffer is not overflowed:\n\n```cpp\nstrncpy(config_file_path + xdg_path_length + 1, config_conf_path, sizeof(config_file_path) - xdg_path_length - 1);\n```\n\nEnsure that `config_file_path` is properly null-terminated:\n\n```cpp\nconfig_file_path[sizeof(config_file_path) - 1] = '\\0';\n```\n\n### Library Dependencies\n\nThe code example provided does not require any additional library dependencies beyond the standard C++ library.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-aa49d472-71e0-4e6d-b8f3-6f8d18439f96",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the use of the `strlen` function in C++ arises when the function is used on a pointer that may not be null-terminated or is not properly validated. This can lead to buffer overflows, undefined behavior, or crashes if the pointer does not point to a valid C-style string. In the specific case of `strlen(xdg_config_dir)`, if `xdg_config_dir` is not properly initialized or validated, it could lead to reading beyond the allocated memory, causing potential security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all input data is validated before use. Check that pointers are not null and point to valid, null-terminated strings.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that provide bounds checking, such as `std::string` in C++.\n3. **Memory Management**: Properly manage memory allocation and deallocation to avoid dangling pointers and ensure that strings are null-terminated.\n4. **Static Analysis**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability associated with `strlen(xdg_config_dir)`, ensure that `xdg_config_dir` is a valid, null-terminated string before calling `strlen`. Here is an example fix:\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n#include <string>  // Required for std::string\n\nint main() {\n    // Example initialization of xdg_config_dir\n    std::string configDir = \"/path/to/config\";\n    const char* xdg_config_dir = configDir.c_str();\n\n    // Ensure xdg_config_dir is not null and is null-terminated\n    if (xdg_config_dir != nullptr && std::strlen(xdg_config_dir) > 0) {\n        std::cout << \"Length of xdg_config_dir: \" << std::strlen(xdg_config_dir) << std::endl;\n    } else {\n        std::cerr << \"Invalid xdg_config_dir\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following libraries are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<cstring>`: For C-style string operations, including `strlen`.\n- `<string>`: For using `std::string` which provides safer string handling.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-ed686c74-d75f-406a-be08-0c14d0dbdda4",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe use of `strncpy` in C++ can lead to vulnerabilities if not handled correctly. `strncpy` is often used to copy strings, but it does not guarantee null-termination if the source string is longer than the specified number of characters. This can lead to buffer overflows, data corruption, and security vulnerabilities, especially if the destination buffer is not properly sized or if the copied string is used without ensuring it is null-terminated.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Consider using safer string handling functions like `strlcpy` or `snprintf` which ensure null-termination.\n2. **Proper Buffer Sizing**: Always ensure that the destination buffer is large enough to hold the source string plus the null terminator.\n3. **Manual Null-Termination**: If using `strncpy`, manually null-terminate the destination buffer.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe string operations in your code.\n\n### Source Code Fix Recommendation\n\nFor the specific vulnerability sink:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Assuming PDEV_LEN is defined and is the size of gpu_infos[*count].base.pdev\nstrncpy(gpu_infos[*count].base.pdev, pciInfo.busIdLegacy, PDEV_LEN - 1);\ngpu_infos[*count].base.pdev[PDEV_LEN - 1] = '\\0'; // Ensure null-termination\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using `strncpy`.\n\n### Relevant Resources\n\n- [OWASP C++ Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)\n\nThese links were verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-957b9707-d599-4382-bf0f-a52a23231b24",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/get_process_info_linux.c"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 2,
                  "endLine": 57,
                  "endColumn": 47,
                  "charOffset": 1607,
                  "charLength": 45,
                  "snippet": {
                    "text": "strncpy(*buffer, user_info->pw_name, namelen)",
                    "rendered": {
                      "text": "strncpy(*buffer, user_info->pw_name, namelen)",
                      "markdown": "`strncpy(*buffer, user_info->pw_name, namelen)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_linux.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1607,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strcpy_s(*buffer,  namelen,  user_info->pw_name)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_linux.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1607,
                        "charLength": 45
                      },
                      "insertedContent": {
                        "text": "strlcpy(*buffer,  user_info->pw_name,  namelen)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fee16a34-ee94-4a93-a9ee-ec7430ec46bf",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (malloc)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/get_process_info_linux.c"
                },
                "region": {
                  "startLine": 75,
                  "startColumn": 12,
                  "endLine": 75,
                  "endColumn": 31,
                  "charOffset": 2068,
                  "charLength": 19,
                  "snippet": {
                    "text": "malloc(size_buffer)",
                    "rendered": {
                      "text": "malloc(size_buffer)",
                      "markdown": "`malloc(size_buffer)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_linux.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2068,
                        "charLength": 19
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a5bac319-6d2c-4ea1-816e-56ec2b913218",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (malloc)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_ring_buffer.c"
                },
                "region": {
                  "startLine": 14,
                  "startColumn": 32,
                  "endLine": 14,
                  "endColumn": 106,
                  "charOffset": 505,
                  "charLength": 74,
                  "snippet": {
                    "text": "malloc(sizeof(unsigned[devices_count][per_device_data_saved][buffer_size])",
                    "rendered": {
                      "text": "malloc(sizeof(unsigned[devices_count][per_device_data_saved][buffer_size])",
                      "markdown": "`malloc(sizeof(unsigned[devices_count][per_device_data_saved][buffer_size])`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_ring_buffer.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 505,
                        "charLength": 74
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ef70b678-ba6d-48f9-999b-41a5433cfcec",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (strlen)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/get_process_info_linux.c"
                },
                "region": {
                  "startLine": 54,
                  "startColumn": 19,
                  "endLine": 54,
                  "endColumn": 45,
                  "charOffset": 1524,
                  "charLength": 26,
                  "snippet": {
                    "text": "strlen(user_info->pw_name)",
                    "rendered": {
                      "text": "strlen(user_info->pw_name)",
                      "markdown": "`strlen(user_info->pw_name)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_linux.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1524,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strlen_s(user_info->pw_name, <size of user_info->pw_name>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/get_process_info_linux.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1524,
                        "charLength": 26
                      },
                      "insertedContent": {
                        "text": "strnlen(user_info->pw_name, <size of user_info->pw_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8214567d-089d-45ab-a2fa-b7c73aba017c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detection of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_intel.c"
                },
                "region": {
                  "startLine": 266,
                  "startColumn": 2,
                  "endLine": 266,
                  "endColumn": 49,
                  "charOffset": 10733,
                  "charLength": 47,
                  "snippet": {
                    "text": "strncpy(thisGPU->base.pdev, pdev_val, PDEV_LEN)",
                    "rendered": {
                      "text": "strncpy(thisGPU->base.pdev, pdev_val, PDEV_LEN)",
                      "markdown": "`strncpy(thisGPU->base.pdev, pdev_val, PDEV_LEN)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_intel.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10733,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "strcpy_s(thisGPU->base.pdev,  PDEV_LEN,  pdev_val)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_intel.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10733,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "strlcpy(thisGPU->base.pdev,  pdev_val,  PDEV_LEN)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e870b06d-196a-4075-aa7d-58cbeefc2158",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 351,
                  "startColumn": 2,
                  "endLine": 351,
                  "endColumn": 52,
                  "charOffset": 14097,
                  "charLength": 50,
                  "snippet": {
                    "text": "strcpy(folder_path, options->config_file_location)",
                    "rendered": {
                      "text": "strcpy(folder_path, options->config_file_location)",
                      "markdown": "`strcpy(folder_path, options->config_file_location)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14097,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "strcpy_s(folder_path, <size of folder_path>,  options->config_file_location)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14097,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "strlcpy(folder_path,  options->config_file_location, <size of folder_path>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-61e643b1-74f1-465f-8233-3a545e92fc58",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (malloc)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 36,
                  "endLine": 135,
                  "endColumn": 63,
                  "charOffset": 5244,
                  "charLength": 27,
                  "snippet": {
                    "text": "malloc(strlen(default_path)",
                    "rendered": {
                      "text": "malloc(strlen(default_path)",
                      "markdown": "`malloc(strlen(default_path)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5244,
                        "charLength": 27
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-11a87b7c-f4c6-49e7-a096-4867559d681c",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 132,
                  "startColumn": 4,
                  "endLine": 132,
                  "endColumn": 58,
                  "charOffset": 5087,
                  "charLength": 54,
                  "snippet": {
                    "text": "strcpy(options->config_file_location, config_location)",
                    "rendered": {
                      "text": "strcpy(options->config_file_location, config_location)",
                      "markdown": "`strcpy(options->config_file_location, config_location)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5087,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "strcpy_s(options->config_file_location, <size of options->config_file_location>,  config_location)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5087,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "strlcpy(options->config_file_location,  config_location, <size of options->config_file_location>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-51d7b0bc-87bc-47c3-b737-7c9f7397ae41",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (strlen)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 135,
                  "startColumn": 43,
                  "endLine": 135,
                  "endColumn": 63,
                  "charOffset": 5251,
                  "charLength": 20,
                  "snippet": {
                    "text": "strlen(default_path)",
                    "rendered": {
                      "text": "strlen(default_path)",
                      "markdown": "`strlen(default_path)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5251,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strlen_s(default_path, <size of default_path>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5251,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "strnlen(default_path, <size of default_path>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-74594c9d-c1de-46c6-ae29-1b271533672d",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (malloc)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 127,
                  "startColumn": 36,
                  "endLine": 127,
                  "endColumn": 66,
                  "charOffset": 4930,
                  "charLength": 30,
                  "snippet": {
                    "text": "malloc(strlen(config_location)",
                    "rendered": {
                      "text": "malloc(strlen(config_location)",
                      "markdown": "`malloc(strlen(config_location)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4930,
                        "charLength": 30
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e53f003a-a787-4483-bccb-60633b86221f",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 55,
                  "startColumn": 4,
                  "endLine": 55,
                  "endColumn": 91,
                  "charOffset": 1835,
                  "charLength": 87,
                  "snippet": {
                    "text": "strcpy(config_file_path + xdg_path_length + 1 + conf_path_length, config_file_location)",
                    "rendered": {
                      "text": "strcpy(config_file_path + xdg_path_length + 1 + conf_path_length, config_file_location)",
                      "markdown": "`strcpy(config_file_path + xdg_path_length + 1 + conf_path_length, config_file_location)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1835,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "strcpy_s(config_file_path + xdg_path_length + 1 + conf_path_length, <size of config_file_path + xdg_path_length + 1 + conf_path_length>,  config_file_location)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1835,
                        "charLength": 87
                      },
                      "insertedContent": {
                        "text": "strlcpy(config_file_path + xdg_path_length + 1 + conf_path_length,  config_file_location, <size of config_file_path + xdg_path_length + 1 + conf_path_length>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a3a5e20d-408b-4714-8840-38765af1cc98",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 4,
                  "endLine": 49,
                  "endColumn": 44,
                  "charOffset": 1572,
                  "charLength": 40,
                  "snippet": {
                    "text": "strcpy(config_file_path, xdg_config_dir)",
                    "rendered": {
                      "text": "strcpy(config_file_path, xdg_config_dir)",
                      "markdown": "`strcpy(config_file_path, xdg_config_dir)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1572,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strcpy_s(config_file_path, <size of config_file_path>,  xdg_config_dir)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1572,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "strlcpy(config_file_path,  xdg_config_dir, <size of config_file_path>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-07baed74-7e74-4402-8486-6fd221306fa5",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 140,
                  "startColumn": 4,
                  "endLine": 140,
                  "endColumn": 55,
                  "charOffset": 5398,
                  "charLength": 51,
                  "snippet": {
                    "text": "strcpy(options->config_file_location, default_path)",
                    "rendered": {
                      "text": "strcpy(options->config_file_location, default_path)",
                      "markdown": "`strcpy(options->config_file_location, default_path)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5398,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "strcpy_s(options->config_file_location, <size of options->config_file_location>,  default_path)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 5398,
                        "charLength": 51
                      },
                      "insertedContent": {
                        "text": "strlcpy(options->config_file_location,  default_path, <size of options->config_file_location>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-81eac07d-62e9-49bd-b91d-e0b7fe5c2d5e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Detected Issue with C Function (strlen)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 127,
                  "startColumn": 43,
                  "endLine": 127,
                  "endColumn": 66,
                  "charOffset": 4937,
                  "charLength": 23,
                  "snippet": {
                    "text": "strlen(config_location)",
                    "rendered": {
                      "text": "strlen(config_location)",
                      "markdown": "`strlen(config_location)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4937,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "strlen_s(config_location, <size of config_location>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4937,
                        "charLength": 23
                      },
                      "insertedContent": {
                        "text": "strnlen(config_location, <size of config_location>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-2aa1d867-653b-4ff1-b7ff-29e170699a6d",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detection of Prohibited C Function (strcpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 52,
                  "startColumn": 6,
                  "endLine": 52,
                  "endColumn": 70,
                  "charOffset": 1693,
                  "charLength": 64,
                  "snippet": {
                    "text": "strcpy(config_file_path + xdg_path_length + 1, config_conf_path)",
                    "rendered": {
                      "text": "strcpy(config_file_path + xdg_path_length + 1, config_conf_path)",
                      "markdown": "`strcpy(config_file_path + xdg_path_length + 1, config_conf_path)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1693,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "strcpy_s(config_file_path + xdg_path_length + 1, <size of config_file_path + xdg_path_length + 1>,  config_conf_path)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1693,
                        "charLength": 64
                      },
                      "insertedContent": {
                        "text": "strlcpy(config_file_path + xdg_path_length + 1,  config_conf_path, <size of config_file_path + xdg_path_length + 1>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-aa49d472-71e0-4e6d-b8f3-6f8d18439f96",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "\"Identified Issue with C Function (strlen)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/interface_options.c"
                },
                "region": {
                  "startLine": 47,
                  "startColumn": 27,
                  "endLine": 47,
                  "endColumn": 49,
                  "charOffset": 1458,
                  "charLength": 22,
                  "snippet": {
                    "text": "strlen(xdg_config_dir)",
                    "rendered": {
                      "text": "strlen(xdg_config_dir)",
                      "markdown": "`strlen(xdg_config_dir)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1458,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strlen_s(xdg_config_dir, <size of xdg_config_dir>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/interface_options.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1458,
                        "charLength": 22
                      },
                      "insertedContent": {
                        "text": "strnlen(xdg_config_dir, <size of xdg_config_dir>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ed686c74-d75f-406a-be08-0c14d0dbdda4",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detection of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/extract_gpuinfo_nvidia.c"
                },
                "region": {
                  "startLine": 407,
                  "startColumn": 8,
                  "endLine": 407,
                  "endColumn": 75,
                  "charOffset": 14598,
                  "charLength": 67,
                  "snippet": {
                    "text": "strncpy(gpu_infos[*count].base.pdev, pciInfo.busIdLegacy, PDEV_LEN)",
                    "rendered": {
                      "text": "strncpy(gpu_infos[*count].base.pdev, pciInfo.busIdLegacy, PDEV_LEN)",
                      "markdown": "`strncpy(gpu_infos[*count].base.pdev, pciInfo.busIdLegacy, PDEV_LEN)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_nvidia.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14598,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "strcpy_s(gpu_infos[*count].base.pdev,  PDEV_LEN,  pciInfo.busIdLegacy)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/extract_gpuinfo_nvidia.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 14598,
                        "charLength": 67
                      },
                      "insertedContent": {
                        "text": "strlcpy(gpu_infos[*count].base.pdev,  pciInfo.busIdLegacy,  PDEV_LEN)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}